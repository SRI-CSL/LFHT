\section{Verification}
\label{sec:veri}

We have modeled a simplified version of the \texttt{add} operation of
the hash table. \todo{list limitations of the model (e.g., counters
  updates are considered atomic, no handle)}. Figure~\ref{fig:model}
shows the configuration diagram for the \texttt{add} operation.

\newcommand{\pczero}{\mbox{init}}
\newcommand{\pcone}{\mbox{ready\hspace{-0.5mm}-to\hspace{-0.5mm}-add}}
\newcommand{\pctwo}{\mbox{added}}
\newcommand{\pcthree}{\mbox{error}}
\newcommand{\negate}[1]{\mbox{$\neg\ #1$}}
\newcommand{\incr}{\mbox{\xspace$+\hspace{-1mm}=$\xspace}}
\newcommand{\decr}{\mbox{\xspace$-\hspace{-1mm}=$\xspace}}
    
\begin{figure}[t]
\begin{tikzpicture}[shorten >=1pt, node distance=5cm, on grid]
  \node[draw,rectangle]   (q_0)      {$\pczero$};
  \node[draw,rectangle] (q_1) [right=of q_0] {$\pcone$};
  \node[draw,rectangle] (q_2) [right=of q_1] {$\pctwo$};
  \node[draw,rectangle] (q_3) [right=of q_2] {$\pcthree$};
  
  \path[->](q_0) edge [bend left=45] node [below] {\textsf{migrate}} (q_1);
  \path[->](q_0) edge [bend right]   node [below] {\textsf{no-migrate}} (q_1);
  \path[->](q_1) edge                node [below] {\textsf{full}} (q_0);
  \path[->](q_1) edge                node [above] {\textsf{add}} (q_2);
  \path[->](q_2) edge [bend right=50]  node [above] {\textsf{grow}} (q_0);
  \path[->](q_2) edge [bend left=50]  node [above] {\textsf{no-grow}} (q_0);  
  \path[->](q_2) edge                node [above] {\textsf{out-of-mem}} (q_3);  
  \path[->](q_3) edge [loop above]   node  {} ();
\end{tikzpicture}
\caption{Configuration diagram for \texttt{add} operation}
\label{fig:model}
\end{figure}

\subsection{Abstract Model for \texttt{add}}

A variable \emph{state} records one of the four possible states shown
in the configuration diagram in Figure~\ref{fig:model}: \emph{\pczero},
\emph{\pcone}, \emph{\pctwo}, and \emph{\pcthree}.

A variable $ht$ represents the hash table in our abstract model.  A
hash table is modeled by a list or sequence of size $N$ of
\texttt{header} elements. The type \texttt{header} is a record of
\texttt{num\_entries}, \texttt{num\_to\_migrate}, and
\texttt{assimilated} where \texttt{num\_entries} is a non-negative
integer that keeps track of the number of entries in the array,
\texttt{num\_to\_migrate} is another non-negative integer that
represents the number of entries that needs to be migrated to the new
array, and \texttt{assimilated} is a boolean that indicates whether
the array has been assimilated or not. Note that our abstract model
ignores the contents of the hash table since they are irrelevant to
the properties we are interested as we shall show later.

\todo{note that $ht$ is in the reverse order (newest is the last)}

\todo{$ht$ is bounded}

Since each time a new array is allocated its size is double the size
of the previous array, our model keeps track of the size of the
current array in a variable $k$.

Our abstract model also needs to know which arrays are the old and the
new which are stored in the variables \texttt{old} and \texttt{new},
respectively.

\todo{Describe \texttt{pending}, \texttt{did\_not\_pay},
  \texttt{paid\_tax}, \texttt{posted}, and \texttt{revenue}.}

\todo{Describe N and MAX (threshold)}

\subsection{Abstract Operations}

\noindent \textbf{Init:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state := \pczero$ \\
  $ht_{i\in \{1,\ldots,N\}} := \{ num\_to\_entries := 0, num\_to\_migrate := 0, assimilated := false \}$ \\  
  $k := 32$ \\
  $old := new := 1$ \\
  $pending := did\_not\_pay := paid\_tax := posted := revenue := 0$}
\end{minipage}

\noindent \textbf{Migrate:}  \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pczero \wedge old \neq new \wedge ht_{old}.assimilated \rightarrow$ \\
  \> $ht_{new}.num\_entries \incr min(T, ht_{old}.num\_to\_migrate)$ \\
  \> $ht_{old}.num\_entries \decr min(T, ht_{old}.num\_to\_migrate)$ \\
  \> $ht_{old}.assimilated := (ht'_{old}.num\_to\_migrate = 0)$ \\
  \> $pending \incr 1$ \\
  \> $paid\_tax \incr 1$ \\
  \> $revenue \incr min(T,ht_{old}.num\_to\_migrate)$\\
  \> $state := \pcone$}
\end{minipage}


\noindent \textbf{No migrate:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pczero \wedge \negate{old \neq new \wedge ht_{old}.assimilated} \rightarrow$ \\
  \> $pending \incr 1$ \\
  \> $state := \pcone$}
\end{minipage}

\noindent \textbf{Added:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcone \wedge ht_{new}.num\_entries < k \rightarrow$ \\
  \> $ht_{new}.num\_entries \incr 1$ \\
  \> $pending \decr 1$ \\
  \> $posted \incr 1$ \\
  \> $state := \pctwo$}
\end{minipage}

\noindent \textbf{Full:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcone \wedge ht_{new}.num\_entries \geq k \rightarrow$ \\
  \> $pending \decr 1$ \\
  \> $did\_not\_pay \decr 1$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{Grow:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge ht_{new}.num\_entries > MAX \times k \wedge new < N \rightarrow$ \\
  \> $k := 2 \times k$ \\
  \> $old := new$ \\
  \> $new \incr 1$ \\
  \> $ht_{new+1}.num\_entries := 0$ \\
  \> $ht_{new+1}.num\_to\_migrate := 0$ \\
  \> $ht_{new+1}.assimilated := false$ \\
  \> $ht_{new}.num\_to\_migrate := ht_{new}.num\_entries$ \\                
  \> $did\_not\_pay := pending$ \\
  \> $paid\_tax :=  revenue := posted := 0$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{No Grow:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge ht_{new}.num\_entries \leq MAX \times k \rightarrow$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{Out of memory:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge ht_{new}.num\_entries > MAX \times k \wedge new \geq N \rightarrow$ \\
  \> $state := \pcthree$}
\end{minipage}

\noindent \textbf{Loop Forever:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcthree \rightarrow state :=\pcthree$ 
}
\end{minipage}


\subsection{Property}


We are interested in proving a key invariant in the implementation of
our hash table. This invariants refers to the fact that migration is
always from the old table to the new one. Informally, for all index $i
\in \{1, \ldots, N\}$ such that $i < old$ then the array $i$ must be
assimilated. This can be stated more formally as follows:

  \[G(\forall 1 \leq i \leq N.~ i < old \Rightarrow ht_{i}.assimilated) \]
  
While proving this property, we will assume that there is a bounded
number of $n$ threads that can call \texttt{add} in an asynchronous
manner.

\subsection{Proving Property with Sal}

Sal\cite{sal2} is a ....

The overall process was based on strengthening the property (which is
not inductive invariant) by adding new lemas obtained by inspecting a
failed proof for inductiveness.

\begin{lemma}
  $G((new = 1 \wedge old = 1) \vee (new = old+1))$
\end{lemma}

\begin{lemma}
  $G(\forall 1 \leq i \leq N.  \wedge i > new \Rightarrow empty(ht_i))$

  \noindent where

  \begin{equation*}
    empty(ht_i)=\left\{
    \begin{array}{ll}
      ht_i.num\_entries = 0  & \wedge \\
      ht_i.num\_to\_migrate = 0 & \wedge \\
      \negate{ht_i.assimilated} & 
    \end{array}
    \right.
  \end{equation*}
  
\end{lemma}  

\begin{lemma}
 $G(\forall 1 \leq i \leq N.  \wedge \negate{full(i, ht_i)} \wedge size(i,ht_i) \Rightarrow \\
       \forall i < j \leq N.  \Rightarrow empty(ht_j))$
\end{lemma}  

\noindent where

  \begin{equation*}
    full(i, ht_i)=\left\{
    \begin{array}{ll}
       & \\
    \end{array}
    \right.
  \end{equation*}

  \begin{equation*}
    size(i, ht_i)=\left\{
    \begin{array}{ll}
       & \\
    \end{array}
    \right.
  \end{equation*}
  

\begin{lemma}
  $G(\forall 1 \leq i \leq N. ht_i.num\_to\_migrate \leq ht_i.num\_entries)$
\end{lemma}  

\begin{lemma}
  $G(size(new,K))$
\end{lemma}  

\begin{lemma}
  $G(\negate{ht_{new}.assimilated})$
\end{lemma}  

\begin{lemma}
  $G(ht_{new}.num\_to\_migrate = 0)$
\end{lemma}  

\begin{lemma}
  $G(old = new \vee full(old, ht_{old}.num\_entries))$
\end{lemma}  

\begin{lemma}
  $G(\forall 1 \leq i \leq N. \negate{full(i,ht_{i})} \Rightarrow \negate{ht_{i}.assimilated})$
\end{lemma}  

\begin{lemma}
  $G(\forall 1 \leq i \leq N. \negate{full(i,ht_{i})} \Rightarrow \negate{ht_{i}.num\_to\_migrate = 0})$
\end{lemma}  

\begin{lemma}
  $G(\forall 1 \leq i \leq N. ht_{i}.assimilated \Rightarrow ht_{i}.num\_to\_migrate = 0)$
\end{lemma}  

\begin{lemma}
  $G()$
\end{lemma}  

%% \begin{tabular}{|l|l|}
%%   \hline
%%   \textsf{Lemma} & \textsf{Assumptions} \\
%%   \hline \\

%% \end{tabular}

\subsection{Proving Property with Sally}

Sally~\cite{sally} is a ...

TODO: not sure if we can say something meaningful.


