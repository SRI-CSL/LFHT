\newcommand{\HT}[1]{\mbox{$ht[#1]$}}

\section{Verification}
\label{sec:veri}

We have modeled a simplified version of the \texttt{add} operation of
the hash table and proved some facts about the growing and data
migration mechanism. Figure~\ref{fig:model} shows the configuration
diagram for the \texttt{add} operation.

\newcommand{\pczero}{\mbox{init}}
\newcommand{\pcone}{\mbox{ready\hspace{-0.5mm}-to\hspace{-0.5mm}-add}}
\newcommand{\pctwo}{\mbox{added}}
\newcommand{\pcthree}{\mbox{error}}
\newcommand{\negate}[1]{\mbox{$\neg\ #1$}}
\newcommand{\incr}{\mbox{\xspace$+\hspace{-1mm}=$\xspace}}
\newcommand{\decr}{\mbox{\xspace$-\hspace{-1mm}=$\xspace}}
    
\begin{figure}[t]
\begin{tikzpicture}[shorten >=1pt, node distance=5cm, on grid]
  \node[draw,rectangle]   (q_0)      {$\pczero$};
  \node[draw,rectangle] (q_1) [right=of q_0] {$\pcone$};
  \node[draw,rectangle] (q_2) [right=of q_1] {$\pctwo$};
  \node[draw,rectangle] (q_3) [right=of q_2] {$\pcthree$};
  
  \path[->](q_0) edge [bend left=45] node [below] {\textsf{migrate}} (q_1);
  \path[->](q_0) edge [bend right]   node [below] {\textsf{no-migrate}} (q_1);
  \path[->](q_1) edge                node [below] {\textsf{full}} (q_0);
  \path[->](q_1) edge                node [above] {\textsf{add}} (q_2);
  \path[->](q_2) edge [bend right=50]  node [above] {\textsf{grow}} (q_0);
  \path[->](q_2) edge [bend left=50]  node [above] {\textsf{no-grow}} (q_0);  
  \path[->](q_2) edge                node [above] {\textsf{out-of-mem}} (q_3);  
  \path[->](q_3) edge [loop above]   node  {} ();
\end{tikzpicture}
\caption{Configuration diagram for \texttt{add} operation}
\label{fig:model}
\end{figure}

\subsection{Abstract Model for \texttt{add}}

The \texttt{add} operation has been modeled as a state machine by
specifying a transition relation on a set of state variables. This
transition relation is stated as guarded commands, where the guard
triggers a particular transition. We first describe the state
variables and then its transitions.

\subsubsection{State Variables}

A variable \emph{state} records one of the four possible states shown
in the configuration diagram in Figure~\ref{fig:model}:
\emph{\pczero}, \emph{\pcone}, \emph{\pctwo}, and \emph{\pcthree}.
%
A variable \emph{ht} represents the hash table in our abstract model.
A hash table is modeled by a list or sequence of size $N$ of
\texttt{header} elements. The type \texttt{header} is a record of
\emph{num\_entries}, \emph{num\_to\_migrate}, and \emph{assimilated}
where \emph{num\_entries} is a non-negative integer that keeps track
of the number of entries in the array, \emph{num\_to\_migrate} is
another non-negative integer that represents the number of entries
that needs to be migrated to the new array, and \emph{assimilated} is
a boolean that indicates whether the array has been assimilated or
not. Note that our abstract model ignores the contents of the hash
table since they are irrelevant to the properties we are interested as
we shall show later. \todo{list limitations of the model (e.g.,
  counters updates are considered atomic, no handle)}

\todo{note that $ht$ is in the reverse order (newest is the last)}

\todo{$ht$ is bounded}

Since each time a new array is allocated its size is double the size
of the previous array, our model keeps track of the size of the
current array in a variable $k$.

Our abstract model also needs to know which arrays are the old and the
new which are stored in the variables \texttt{old} and \texttt{new},
respectively.

\todo{Describe \texttt{pending}, \texttt{did\_not\_pay},
  \texttt{paid\_tax}, \texttt{posted}, and \texttt{revenue}.}

\todo{Describe (and better names) N (number of arrays), MAX
  (occupation percentage before growing), k (size of the new table), T
  (number of entries to migrate), and NUM\_THREADS (number of
  threads)}

\subsubsection{Transitions}

\noindent \textbf{Init:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state := \pczero$ \\
  $\HT{i\in \{1,\ldots,N\}} := \{ num\_to\_entries := 0, num\_to\_migrate := 0, assimilated := false \}$ \\  
  $k := 32$ \\
  $old := new := 1$ \\
  $pending := did\_not\_pay := paid\_tax := posted := revenue := 0$}
\end{minipage}

\noindent \textbf{Migrate:}  \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pczero \wedge old \neq new \wedge \HT{old}.assimilated \rightarrow$ \\
  \> $\HT{new}.num\_entries \incr min(T, \HT{old}.num\_to\_migrate)$ \\
  \> $\HT{old}.num\_entries \decr min(T, \HT{old}.num\_to\_migrate)$ \\
  \> $\HT{old}.assimilated := (ht'_{old}.num\_to\_migrate = 0)$ \\
  \> $pending \incr 1$ \\
  \> $paid\_tax \incr 1$ \\
  \> $revenue \incr min(T,\HT{old}.num\_to\_migrate)$\\
  \> $state := \pcone$}
\end{minipage}


\noindent \textbf{No migrate:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pczero \wedge \negate{old \neq new \wedge \HT{old}.assimilated} \rightarrow$ \\
  \> $pending \incr 1$ \\
  \> $state := \pcone$}
\end{minipage}

\noindent \textbf{Added:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcone \wedge \HT{new}.num\_entries < k \rightarrow$ \\
  \> $\HT{new}.num\_entries \incr 1$ \\
  \> $pending \decr 1$ \\
  \> $posted \incr 1$ \\
  \> $state := \pctwo$}
\end{minipage}

\noindent \textbf{Full:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcone \wedge \HT{new}.num\_entries \geq k \rightarrow$ \\
  \> $pending \decr 1$ \\
  \> $did\_not\_pay \decr 1$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{Grow:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge \HT{new}.num\_entries > MAX \times k \wedge new < N \rightarrow$ \\
  \> $k := 2 \times k$ \\
  \> $old := new$ \\
  \> $new \incr 1$ \\
  \> $\HT{new+1}.num\_entries := 0$ \\
  \> $\HT{new+1}.num\_to\_migrate := 0$ \\
  \> $\HT{new+1}.assimilated := false$ \\
  \> $\HT{new}.num\_to\_migrate := \HT{new}.num\_entries$ \\                
  \> $did\_not\_pay := pending$ \\
  \> $paid\_tax :=  revenue := posted := 0$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{No Grow:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge \HT{new}.num\_entries \leq MAX \times k \rightarrow$ \\
  \> $state := \pczero$}
\end{minipage}

\noindent \textbf{Out of memory:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pctwo \wedge \HT{new}.num\_entries > MAX \times k \wedge new \geq N \rightarrow$ \\
  \> $state := \pcthree$}
\end{minipage}

\noindent \textbf{Sink state:} \vspace{1mm}

\begin{minipage}{\linewidth}
\pcode[\small]{
  $state=\pcthree \rightarrow state :=\pcthree$ 
}
\end{minipage}

We assume that there is an arbitrary (but bounded) number of threads
calling the \texttt{add} operation in an asynchronous manner. For
convenience, we will refer to $state[i]$ as the value of the state
variable for thread $i$.

\subsection{Proving Correctness of a Key Invariant about the Migration Mechanism}

We are interested in proving a key invariant in the implementation of
our hash table. This invariant reflects that migration is always from
the old table to the new one regardless of the number of
copies. Informally, for all indexes $i \in \{1, \ldots, N\}$ such that
$i < old$ then the array $i$ must be assimilated. This can be stated
more formally as follows:

  \[ G(\forall 1 \leq i \leq N.~ i < old \Rightarrow \HT{i}.assimilated) \]

Current verification technology can only hope for proving whether a
property is \emph{inductive invariant}. Informally, given a state
machine defined by $Init(x)$, a formula over a set of state variables
$x$ that represents the set of initial states, and $Tr(x,x')$, the
transition relation defining the new values $x'$ from the old values
$x$, we say that a property $Inv(x)$ is inductive invariant if:

\begin{enumerate}
\item $Init(x) \Rightarrow Inv(x)$
\item $Inv(x) \wedge Tr(x,x') \Rightarrow Inv(x')$
\end{enumerate}

Unfortunately, the key invariant we wish to prove is not inductive
invariant. A common solution to this problem is to find a
\emph{strengthening} of the property we want to prove, $Inv'(x)$, such
that $Inv(x)$ in conjunction with $Inv'(x)$ becomes inductive. That
is,

\begin{enumerate}
\item $Init(x) \Rightarrow (Inv(x) \wedge Inv'(x))$
\item $(Inv(x) \wedge Inv'(x)) \wedge Tr(x,x') \Rightarrow (Inv(x') \wedge Inv'(x'))$
\end{enumerate}

Complementary to strenghtening, another effective technique is
$k$-induction~\cite{MouraRS03}, which is a generalization of
induction\footnote{Induction is $k$-induction for $k=1$.}. We say a
property $Inv(x)$ is $k$-inductive if:

\begin{enumerate}
\item $Init(x) \Rightarrow Inv(x)$
\item $Inv(x) \wedge Tr(x,x') \wedge \ldots \wedge Inv(x^{k-1}) \wedge Tr(x^{k-1},x^{k}) \Rightarrow Inv(x^{k})$
\end{enumerate}


We used Sally~\cite{sally} a state-of-the-art model checker developed
by SRI that combines k-induction with IC3~\cite{Bradley11}, a powerful
technique to generate inductive invariants. A very appealing feature
of Sally is its ability to discover fully automatically non-trivial
inductive invariants about state machines that can be used to
strengthen the desired property.
%
Thus, we encoded the state machine from the previous section together
with the key invariant we want to prove into Sally format and ran
Sally on it. Unfortunately, Sally was not able to find an inductive
strengthening in a reasonable amount of time.

Since, it is not likely that current verification technology can prove
our key invariant in a fully automatic manner we decided to help the
verification process by manually adding auxiliary lemmas that can make
our property inductive.
%
For this, we used Sal 2~\cite{sal2}, a verification framework
developed also by SRI. Sal 2 provides an infinite model checking
algorithm based only on k-induction which is less powerful than
Sally. However, Sal 2 allows to write lemmas in a very expressive
language which makes it more amenable for this semi-automatic
process. The overall process was based on strengthening the property
by adding new lemas obtained by inspecting a failed proof for
inductiveness. We were able to prove semi-automatically that our key
invariant holds up to 6 threads. For that, we needed to come up with
32 lemmas.

\todo{Group lemmas by categories}.

\begin{lemma} %lemma1
  $G((new = 1 \wedge old = 1) \vee (new = old+1))$
    \label{lemma1}
\end{lemma}

\begin{lemma} %lemma2
  $G(\forall 1 \leq i \leq N.  \wedge i > new \Rightarrow \mathsf{empty}(\HT{i}))$

  \noindent where $\mathsf{empty}(\HT{i})= \HT{i}.num\_entries = 0 \wedge
  \HT{i}.num\_to\_migrate = 0 \wedge \negate{\HT{i}.assimilated}$
  \label{lemma2}  
\end{lemma}  

\begin{lemma} %lemma2a
 $G(\forall 1 \leq i \leq N.  \wedge \negate{\mathsf{full}(i, \HT{i})}
  \wedge \mathsf{size}(i,\HT{i}) \Rightarrow \forall i < j \leq N.
  \Rightarrow \mathsf{empty}(\HT{j}))$

\noindent where $\mathsf{full}(i, \HT{i})= \ldots$, and \\
$\mathsf{size}(i, \HT{i})=\ldots$
  \label{lemma2a}
\end{lemma}

\begin{lemma} %lemma3
  $G(\forall 1 \leq i \leq N. \HT{i}.num\_to\_migrate \leq \HT{i}.num\_entries)$
    \label{lemma3}
\end{lemma}  

\begin{lemma} %lemma4
  $G(size(new,K))$
    \label{lemma4}
\end{lemma}  

\begin{lemma} %lemma5a
  $G(\negate{\HT{new}.assimilated})$
    \label{lemma5a}
\end{lemma}  

\begin{lemma} %lemma5b
  $G(\HT{new}.num\_to\_migrate = 0)$
    \label{lemma5b}
\end{lemma}  

\begin{lemma} %lemma5c 
  $G(old = new \vee full(old, \HT{old}.num\_entries))$
    \label{lemma5c}
\end{lemma}  

\begin{lemma} %lemma5e
  $G(\forall 1 \leq i \leq N. \negate{full(i,\HT{i})} \Rightarrow \negate{\HT{i}.assimilated})$
  \label{lemma5e}  
\end{lemma}  

\begin{lemma} %lemma5f
  $G(\forall 1 \leq i \leq N. \negate{full(i,\HT{i})} \Rightarrow \negate{\HT{i}.num\_to\_migrate = 0})$
  \label{lemma5f}
\end{lemma}  

\begin{lemma} %lemma5g
  $G(\forall 1 \leq i \leq N. \HT{i}.assimilated \Rightarrow \HT{i}.num\_to\_migrate = 0)$
  \label{lemma5g}  
\end{lemma}  

\begin{lemma} %lemma6
  \begin{equation*}
    \begin{array}{l}
    G(\forall 1 \leq i \leq N. i \leq old \wedge old < new \Rightarrow  \\
    \quad (\mathsf{full}(i, \HT{i}) \Rightarrow \HT{i}.num\_to\_migrate = 0 \Longleftrightarrow \HT{i}.assimilated) \wedge \\
    \quad (\negate{\mathsf{full}(i, \HT{i})} \Rightarrow \negate{(\HT{i}.num\_to\_migrate = 0 \wedge \HT{i}.assimilated)}))
    \end{array}
  \end{equation*}
  \label{lemma6}  
\end{lemma}  

\begin{lemma} % lemma8b
  \begin{equation*}
    \begin{array}{l}
      G( old \neq new \wedge \mathsf{migrated}(ht,old) = 0 \wedge \HT{new}.num\_entries = 0 \Rightarrow \\
      \exists 1 \leq i \leq NUM\_THREADS. state[i] = \pczero)
    \end{array}
  \end{equation*}

  where $\mathsf{migrated} = \ldots$
  \label{lemma8b}
\end{lemma}

\begin{lemma} %pending_pos
  $G(pending \geq 0)$
  \label{pending-pos}
\end{lemma}  

\begin{lemma} %pending_upper
  $G(pending \leq NUM\_THREADS)$
  \label{pending-upper}
\end{lemma}  

\begin{lemma} %did_not_pay_1
  $G(did\_not\_pay < NUM\_THREADS)$
    \label{did-not-pay-1}    
\end{lemma}  

\begin{lemma} %paid_tax_0
  $G( old = new \Rightarrow paid\_tax = 0)$
  \label{paid-tax-0}    
\end{lemma}  

\begin{lemma} %paid_tax_1
  $G(paid\_tax \geq 0)$
    \label{paid-tax-1}  
\end{lemma}

\begin{lemma} %revenue_0
  $G(old = new \Rightarrow revenue = 0)$
  \label{revenue0}    
\end{lemma}

\begin{lemma} %revenue_1
  $G( revenue \geq 0)$
  \label{revenue1}    
\end{lemma}

\begin{lemma} %revenue_2
  $G(old < new \Rightarrow revenue = \mathsf{migrated}(ht,old))$
  \label{revenue2}    
\end{lemma}

\begin{lemma} %revenue_3
  $G(old < new \Rightarrow revenue \leq \HT{old}.num\_entries)$
  \label{revenue3}    
\end{lemma}

\begin{lemma} %revenue_4
  $G(old < new \wedge \HT{old}.num\_to\_migrate > 0 \Rightarrow revenue = T \times paid\_tax)$
  \label{revenue4}    
\end{lemma}

\begin{lemma} %revenue_5
  $G(old < new \wedge \HT{old}.num\_to\_migrate > 0 \Rightarrow revenue = \HT{old}.num\_entries)$
  \label{revenue5}  
\end{lemma}

\begin{lemma} %posted_0
  $G(posted \geq 0)$
  \label{posted0}  
\end{lemma}

\begin{lemma} %posted_1
  $G(old < new \wedge h_{old}.assimilated \Rightarrow posted+ pending = paid\_tax + did\_not\_pay)$
  \label{posted1}
\end{lemma}

\begin{lemma} %final
  $G(\exists 1 \leq i \leq NUM\_THREADS. state[i] = \pcthree \Rightarrow new = N)$
  \label{final}  
\end{lemma}


\begin{lemma} %upper_global
  $G(\forall 1 \leq i < N. \HT{i}.num\_entries \leq (MAX \times \mathsf{max\_size}(i)) + NUM\_THREADS)$
  \label{upper-global}
\end{lemma}

\begin{lemma} %upper
  $G(old < new \wedge \negate{\HT{old}.assimilated} \Rightarrow \HT{new}.num\_entries \leq \mathsf{migrated}(ht,old) + (\mathsf{migrated}(ht,old) / T) + (NUM\_THREADS -1) + pending)$
  \label{upper}
\end{lemma}

\begin{lemma} %upper_strengthening_2
  $G(old < new \Rightarrow \HT{new}.num\_entries \leq T \times paid\_tax + posted)$
  \label{upper-strengthening-2}
\end{lemma}

\begin{lemma} %upper_strengthening_3
  $G(old < new \wedge \HT{old}.num\_to\_migrate \geq t \Rightarrow \HT{new}.num\_entries = T * paid\_tax + posted)$
  \label{upper-strengthening-3}  
\end{lemma}

\begin{lemma} %upper_strengthening_5
  $G(old < new \Rightarrow \HT{new}.num\_entries =\mathsf{migrated}(ht,old) + posted )$
  \label{upper-strengthening-5}  
\end{lemma}


\paragraph{Experiments.} TODO


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \textsf{Lemma} & \textsf{Assumed Lemmas} \\
      \hline     
      \ref{lemma1}   & $\emptyset$  \\
      \ref{lemma2}   & $\{$ \ref{lemma1} $\}$ \\
      \ref{lemma2a}  & $\emptyset$  \\
      \ref{lemma3}   & $\emptyset$  \\
      \ref{lemma4}   & $\emptyset$  \\
      \ref{lemma5a}  & $\{$ \ref{lemma1},\ref{lemma4} $\}$ \\
      \ref{lemma5b}  & $\{$ \ref{lemma1},\ref{lemma4} $\}$ \\
      \ref{lemma5c}  & $\{$ \ref{lemma1},\ref{lemma4} $\}$ \\
      \ref{lemma5e}  & $\{$ \ref{lemma4},\ref{lemma5c} $\}$ \\
      \ldots & \\
      \hline 
    \end{tabular}
    \caption{Assumed lemmas}
    \label{lemma-dependencies}
    \end{center}
\end{figure}


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|c|l|l|}
      \hline
      \textsf{\# Threads} & \textsf{K} & \textsf{Time(seconds)} \\
      \hline
      2 & & \\
      3 & & \\
      4 & & \\
      5 & & \\
      6 & &  \\
      \hline 
    \end{tabular}
    \caption{Proving key invariant with Sal 2 up to 6 threads}
    \label{sal-results}
    \end{center}
\end{figure}


